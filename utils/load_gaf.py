"Load gaf file from alignment"
import pandas as pd 
from .load_gfa import load_gfa

## Graph Aligner Output
# meaning of some tags GAF format
ABBV = dict(
    NM="edit distance to the reference",
    AS="alignment score generated by aligner",
    id="residue matches / alignment block length",
    dv="dv",
    bq="bq",
    cs="cs"
)

# Load GAF (Graph alignment format)
COLS_GRAPHALIGNER=[
    "query_seq_name",   #0
    "query_seq_len",    #1
    "query_start",      #2
    "query_end",        #3
    "strand_rel_path",  #4
    "path_matching",    #5
    "path_len",         #6
    "start_pos_path",   #7
    "end_pos_path",     #8
    "num_residue_matches",  #9
    "alignment_block_len",  #10
    "mapping_quality",      #11
    "NM",   #12
    "AS",   #13
    "dv",   #14
    "id",   #15
    "cigar" #16
]

COLS_GIRAFFE=[
    "query_seq_name",   #0
    "query_seq_len",    #1
    "query_start",      #2
    "query_end",        #3
    "strand_rel_path",  #4
    "path_matching",    #5
    "path_len",         #6
    "start_pos_path",   #7
    "end_pos_path",     #8
    "num_residue_matches",  #9
    "alignment_block_len",  #10
    "mapping_quality",      #11
    "AS",   #12
    "bq",   #13
    "cs",   #14
    "dv"    #15
]

## Graph Aligner Output
def load_gaf(path_gaf, path_gfa=None, aligner="GraphAligner"):
    
    gaf=pd.read_csv(path_gaf, sep="\t", header=None)
    gaf.dropna(axis=0, inplace=True)

    if aligner.lower()=="graphaligner": 
        gaf.columns = COLS_GRAPHALIGNER

        # tags specific to graphaligner's output        
        gaf["NM"] = gaf["NM"].apply(lambda v: int(v.split(":")[-1]))
        gaf["id"] = gaf["id"].apply(lambda v: float(v.split(":")[-1]))

    elif aligner.lower()=="giraffe":
        gaf.columns = COLS_GIRAFFE
        gaf["id"] = gaf.apply(lambda row: float(row["num_residue_matches"]) / float(row["alignment_block_len"]), axis=1)

    if path_gfa: 
        # check paths 
        # load GFA
        nodes, edges, paths=load_gfa(path_gfa, return_nodes_path=True)

        # paths in GFA format for direct comparison
        paths = {pid: "".join([">"+n for n in nodes]) for pid,nodes in paths.items()}

        # check number of paths the reads is contained in 
        gaf["num_alignment_subpath_gfa"] = gaf["path_matching"].apply(lambda subpath: sum([subpath in p for p in paths.values()]))
    
    # tags common to graphaligner and giraffe's output
    # gaf["AS"] = gaf["AS"].apply(lambda v: float(v.split(":")[-1]))

    return gaf